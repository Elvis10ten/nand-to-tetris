package compiler.project_11

import compiler.HACK_CHARACTER_SET
import compiler.JackTokenizer
import compiler.Token

/**
 * This module runs the compilation process.
 *
 * The CompilationEngine gets its input from a [JackTokenizer] and uses a VMWriter
 * for writing the VM code output.
 *
 * The output is generated by a series of compileXXX routines, each designed to handle the compilation of a specific Jack language construct XXX
 * (for example, 'compileWhile' generates the VM code that realizes while statements).
 *
 * The contract between these routines is as follows:
 * 1. Each compileXXX routine gets from the input and handles all the tokens that make up XXX,
 * advances the tokenizer exactly beyond these tokens, and emits to the output VM code effecting the semantics of XXX.
 * 2. If XXX is a part of an expression, and thus has a value, the emitted VM code should compute this value and leave it
 * at the top of the stack. As a rule, each compileXXX routine is called only if the current token is XXX.
 * 3. Since the first token in a valid .jack file must be the keyword class, the compilation process starts by calling the
 * routine 'compileClass'.
 */
class CompilationEngine(
    private val tokenizer: JackTokenizer,
    private val writer: VMWriter,
    private val classLevelSymbolTable: SymbolTable
) {

    private val subroutineLevelSymbolTable = SymbolTable()
    private lateinit var thisClassName: String
    private var internalLabelCount = 0


    private val classVarKinds = arrayOf(
        Token.Keyword.STATIC,
        Token.Keyword.FIELD
    )
    private val subroutineKinds = arrayOf(
        Token.Keyword.CONSTRUCTOR,
        Token.Keyword.FUNCTION,
        Token.Keyword.METHOD
    )

    /**
     * When starting to compile a class, the compiler adds all the field and static variables declared in the class
     * declaration to the [classLevelSymbolTable].
     *
     * The compiler also creates an empty subroutine-level symbol table.
     * Since we use one [CompilationEngine] per class, it suffices to just declare [subroutineLevelSymbolTable] and initialize it once.
     *
     * No VM code is generated by this function.
     */
    fun compileClass() {
        process(Token.Keyword.CLASS)
        thisClassName = processIdentifier().value
        process(Token.Symbol.OPENING_CURLY_BRACE)

        // Handles the class's variable declarations. This is expressed in Jack's Grammar as "classVarDec*".
        while (tokenizer.getCurrentToken(advance = false) in classVarKinds) {
            compileClassVarDec()
        }

        // Handles the class's subroutine declarations. This is expressed in Jack's Grammar as "subroutineDec*".
        while (tokenizer.getCurrentToken(advance = false) in subroutineKinds) {
            compileSubroutineDec()
        }

        process(Token.Symbol.CLOSING_CURLY_BRACE)
    }

    /**
     * Compiles a static variable declaration, or a field declaration.
     */
    private fun compileClassVarDec() {
        val varKindToken = process(*classVarKinds)
        val varTypeToken = processType()
        val varName = processIdentifier()

        classLevelSymbolTable.define(
            varName.value,
            varTypeToken.valueString,
            SymbolTable.Kind.get(varKindToken.value)
        )

        // Handles additional variables declared on the same line. This is expressed in Jack's Grammar as "(',', varName)*".
        while(tokenizer.getCurrentToken(advance = false) == Token.Symbol.COMMA) {
            process(Token.Symbol.COMMA)
            val additionalVarName = processIdentifier()

            // Additional variables share the same type.
            classLevelSymbolTable.define(
                additionalVarName.value,
                varTypeToken.valueString,
                SymbolTable.Kind.get(varKindToken.value)
            )
        }

        process(Token.Symbol.SEMI_COLON)
    }

    /**
     * Compiles a complete method, function, or constructor.
     */
    private fun compileSubroutineDec() {
        // Initializes the subroutine's symbol table when compiling a new subroutine.
        subroutineLevelSymbolTable.reset()

        // Stage 1: Subroutine's declaration.
        val subroutineKind = process(*subroutineKinds)
        // Gets the return type of the subroutine. Handles "('void' | type)".
        val subroutineReturnType = process(
            Token.Keyword.VOID,
            *getTypeTokens(tokenizer.getCurrentToken(advance = false)!!)
        )
        // And the subroutine's name.
        val subroutineName = processIdentifier()

        // Stage 2: Subroutine's parameters.
        process(Token.Symbol.OPENING_PARENTHESIS)
        // All subroutines of type method have an implicit "this" argument.
        if (subroutineKind == Token.Keyword.METHOD) {
            subroutineLevelSymbolTable.define(MemorySegment.THIS.id, thisClassName, SymbolTable.Kind.ARG)
        }
        // Adds to the symbol table all the parameters, if any, declared in the subroutine's parameter list.
        compileParameterList()
        process(Token.Symbol.CLOSING_PARENTHESIS)

        // Stage 3: Subroutines local variables.
        process(Token.Symbol.OPENING_CURLY_BRACE)
        // Handles "varDec*" (i.e. the var declarations), if any, by adding to the symbol table all the subroutine's local variables.
        while (tokenizer.getCurrentToken(advance = false) == Token.Keyword.VAR) {
            compileVarDec()
        }

        writer.writeFunction(
            subroutineName = "$thisClassName.${subroutineName.value}",
            numVars = subroutineLevelSymbolTable.getVarCount(SymbolTable.Kind.VAR)
        )

        when (subroutineKind) {
            Token.Keyword.METHOD -> {
                // This sequence aligns the virtual memory segment "this" with the base address of the object on which the method was called.
                writer.writePush(MemorySegment.ARGUMENT, 0)
                writer.writePop(MemorySegment.POINTER, 0)
            }
            Token.Keyword.CONSTRUCTOR -> {
                // This results in allocating a memory block of numFields 16-bit words and aligning the virtual memory segment
                // "this" with the base address of the newly allocated block.
                val numFields = classLevelSymbolTable.getVarCount(SymbolTable.Kind.FIELD)
                writer.writePush(MemorySegment.CONSTANT, numFields)
                writer.writeCall("Memory.alloc", numArgs = 1)
                writer.writePop(MemorySegment.POINTER, 0)
            } else -> {
                // Do nothing for special for static coroutines.
            }
        }

        // Stage 4: Subroutines body.
        compileSubroutineBody()
        process(Token.Symbol.CLOSING_CURLY_BRACE)
    }

    /**
     * Compiles a (possibly empty) parameter list.
     * Does not handle the enclosing parenthesis tokens "(" and ")".
     */
    private fun compileParameterList() {
        // If the first token we see is not a type, then it means there are no parameters i.e. just an empty parenthesis "()".
        val firstToken = tokenizer.getCurrentToken(advance = false)!!
        if (firstToken !in getTypeTokens(firstToken)) {
            return
        }

        // Handles the first parameter.
        val parameterType = processType()
        val parameterName = processIdentifier()
        subroutineLevelSymbolTable.define(
            parameterName.value,
            parameterType.valueString,
            SymbolTable.Kind.ARG
        )

        // Handles additional parameters. From the Jack's grammar: "(',', type varName)*".
        while (tokenizer.getCurrentToken(advance = false) == Token.Symbol.COMMA) {
            process(Token.Symbol.COMMA)
            val additionalParameterType = processType()
            val additionalParameterName = processIdentifier()
            subroutineLevelSymbolTable.define(
                additionalParameterName.value,
                additionalParameterType.valueString,
                SymbolTable.Kind.ARG
            )
        }
    }

    /**
     * Compiles a subroutine's body.
     */
    private fun compileSubroutineBody() {
        // Handles "statement*"
        compileStatements()
    }

    /**
     * Compiles a var declaration.
     */
    private fun compileVarDec() {
        process(Token.Keyword.VAR)
        val varType = processType()
        val varName = processIdentifier()

        // Add first variable to symbol table.
        subroutineLevelSymbolTable.define(
            varName.value,
            varType.valueString,
            SymbolTable.Kind.VAR
        )

        // Handles "(',', varName)*", i.e. any additional variables.
        while(tokenizer.getCurrentToken(advance = false) == Token.Symbol.COMMA) {
            process(Token.Symbol.COMMA)
            val additionalVarName = processIdentifier()
            // Add first variable to symbol table.
            subroutineLevelSymbolTable.define(
                additionalVarName.value,
                varType.valueString,
                SymbolTable.Kind.VAR
            )
        }

        process(Token.Symbol.SEMI_COLON)
    }

    /**
     * Compiles a sequence of statements. Does not handle the enclosing curly bracket tokens "{" and "}".
     */
    private fun compileStatements() {
        while(true) {
            when (tokenizer.getCurrentToken(advance = false)) {
                Token.Keyword.IF -> compileIf()
                Token.Keyword.WHILE -> compileWhile()
                Token.Keyword.DO -> compileDo()
                Token.Keyword.LET -> compileLet()
                Token.Keyword.RETURN -> compileReturn()
                else -> break
            }
        }
    }

    private fun lookupSymbol(name: String): SymbolTable.Symbol {
        return lookupSymbolOptional(name) ?: throw IllegalArgumentException("$name variable wasn't found in symbol tables. Was it defined?")
    }

    private fun lookupSymbolOptional(name: String): SymbolTable.Symbol? {
        return subroutineLevelSymbolTable.findSymbol(name) ?: classLevelSymbolTable.findSymbol(name)
    }

    /**
     * Compiles a LET statement.
     */
    private fun compileLet() {
        process(Token.Keyword.LET)
        val varName = processIdentifier()
        val varSymbol = lookupSymbol(varName.value)

        if (tokenizer.getCurrentToken(advance = false) == Token.Symbol.OPENING_BRACKET) {
            // Handles arrays. First, compute the expression in the square bracket.
            process(Token.Symbol.OPENING_BRACKET)
            compileExpression()
            process(Token.Symbol.CLOSING_BRACKET)
            // Then, push the array pointer to the stack.
            writer.writePush(varSymbol.kind.memorySegment, varSymbol.index)
            // The computed expression is at the top of the stack and provides the index into the array.
            // Add it to the base array pointer to get the actual address referred to by the index.
            writer.writeArithmeticLogical(ArithmeticLogicalOperation.ADD)

            // Then compute the value on the right hand side
            process(Token.Symbol.EQUAL)
            compileExpression()

            /*
            * We use the "THAT" virtual register when dealing with arrays.
            * It is possible that the right hand side might also be an array.
            * Hence, we delay setting "THAT" for the left hand side until after the right hand side is written.
            * This ensures that the right hand side doesn't overwrite "THAT" for the left hand side.
             */

            // Save the right hand value into a temporary register.
            writer.writePop(MemorySegment.TEMP, 0)
            // The stack top now points to the left hand side array address, i.e. addressOf(array[i]). Set this value to "that".
            writer.writePop(MemorySegment.POINTER, 1)
            // Then write the value from the temporary register into "that [0]".
            writer.writePush(MemorySegment.TEMP, 0)
            writer.writePop(MemorySegment.THAT, 0)
        } else {
            process(Token.Symbol.EQUAL)
            compileExpression()
            writer.writePop(varSymbol.kind.memorySegment, varSymbol.index)
        }

        process(Token.Symbol.SEMI_COLON)
    }

    private fun assignInternalLabel(prefix: String): String {
        val internalLabelName = "$thisClassName.$prefix.$internalLabelCount"
        internalLabelCount++
        return internalLabelName
    }

    /**
     * Compiles an IF statement (possibly with a trailing else clause).
     */
    private fun compileIf() {
        process(Token.Keyword.IF)
        process(Token.Symbol.OPENING_PARENTHESIS)
        compileExpression()
        process(Token.Symbol.CLOSING_PARENTHESIS)
        writer.writeArithmeticLogical(ArithmeticLogicalOperation.NOT)

        val elseLabel = assignInternalLabel(prefix = "condition_else")
        // Goto else label if condition is false.
        writer.writeIfGoto(elseLabel)

        process(Token.Symbol.OPENING_CURLY_BRACE)
        compileStatements()
        process(Token.Symbol.CLOSING_CURLY_BRACE)

        // This will skip past the end clause (if it exists).
        val conditionEndLabel = assignInternalLabel(prefix = "condition_end")
        writer.writeGoto(conditionEndLabel)

        // Mark the start of the else clause (if it exists).
        writer.writeLabel(elseLabel)
        if (tokenizer.getCurrentToken(advance = false) == Token.Keyword.ELSE) {
            process(Token.Keyword.ELSE)
            process(Token.Symbol.OPENING_CURLY_BRACE)
            compileStatements()
            process(Token.Symbol.CLOSING_CURLY_BRACE)
        }

        // Mark the end of the conditional
        writer.writeLabel(conditionEndLabel)
    }

    /**
     * Compiles a WHILE statement.
     */
    private fun compileWhile() {
        // Marks the start of the loop.
        val loopStartLabel = assignInternalLabel(prefix = "loop_start")
        writer.writeLabel(loopStartLabel)

        process(Token.Keyword.WHILE)
        process(Token.Symbol.OPENING_PARENTHESIS)
        compileExpression()
        process(Token.Symbol.CLOSING_PARENTHESIS)

        writer.writeArithmeticLogical(ArithmeticLogicalOperation.NOT)
        // This will skip past the loop statements if the loop condition is false.
        val loopEndLabel = assignInternalLabel(prefix = "loop_end")
        writer.writeIfGoto(loopEndLabel)

        process(Token.Symbol.OPENING_CURLY_BRACE)
        compileStatements()
        process(Token.Symbol.CLOSING_CURLY_BRACE)

        // Repeat until condition is false.
        writer.writeGoto(loopStartLabel)

        // Mark the end of the loop.
        writer.writeLabel(loopEndLabel)
    }

    /**
     * Compiles a DO statement.
     */
    private fun compileDo() {
        process(Token.Keyword.DO)

        // Compiling do subroutineCall statements as if they were "do expression" statements,
        // and then yanking the topmost stack value using pop temp 0.
        compileExpression()
        writer.writePop(MemorySegment.TEMP, index = 0)

        process(Token.Symbol.SEMI_COLON)
    }

    /**
     * Compiles a RETURN statement.
     */
    private fun compileReturn() {
        process(Token.Keyword.RETURN)

        if (tokenizer.getCurrentToken(advance = false) != Token.Symbol.SEMI_COLON) {
            compileExpression()
        } else {
            // Every VM function is expected to push a value onto the stack before returning.
            // When compiling a void Jack method or function, the convention is to end the generated code with "push constant 0, return".
            writer.writePush(MemorySegment.CONSTANT, 0)
        }

        process(Token.Symbol.SEMI_COLON)
        writer.writeReturn()
    }

    /**
     * Compiles an expression.
     */
    private fun compileExpression() {
        compileTerm()

        val binaryOperations = arrayOf(
            Token.Symbol.PLUS,
            Token.Symbol.DASH,
            Token.Symbol.ASTERISK,
            Token.Symbol.SLASH,
            Token.Symbol.AMPERSAND,
            Token.Symbol.PIPE,
            Token.Symbol.LESS_THAN,
            Token.Symbol.GREATER_THAN,
            Token.Symbol.EQUAL
        )

        while (tokenizer.getCurrentToken(advance = false) in binaryOperations) {
            val operation = process(*binaryOperations)
            compileTerm()

            // We expect both operands to be at the stack's top.
            when (operation) {
                Token.Symbol.PLUS -> {
                    writer.writeArithmeticLogical(ArithmeticLogicalOperation.ADD)
                }
                Token.Symbol.DASH -> {
                    writer.writeArithmeticLogical(ArithmeticLogicalOperation.SUB)
                }
                Token.Symbol.ASTERISK -> {
                    writer.writeCall(subroutineName = "Math.multiply", numArgs = 2)
                }
                Token.Symbol.SLASH -> {
                    writer.writeCall(subroutineName = "Math.divide", numArgs = 2)
                }
                Token.Symbol.AMPERSAND -> {
                    writer.writeArithmeticLogical(ArithmeticLogicalOperation.AND)
                }
                Token.Symbol.PIPE -> {
                    writer.writeArithmeticLogical(ArithmeticLogicalOperation.OR)
                }
                Token.Symbol.LESS_THAN -> {
                    writer.writeArithmeticLogical(ArithmeticLogicalOperation.LT)
                }
                Token.Symbol.GREATER_THAN -> {
                    writer.writeArithmeticLogical(ArithmeticLogicalOperation.GT)
                }
                Token.Symbol.EQUAL -> {
                    writer.writeArithmeticLogical(ArithmeticLogicalOperation.EQ)
                }
                else -> throw IllegalStateException("Shouldn't happen.")
            }
        }
    }

    /**
     * Compiles a term.
     *
     * If the current token is an identifier, the routine must resolve it into:
     * 1. a variable,
     * 2. an array element, or
     * 3. a subroutine call.
     *
     * A single lookahead token, which may be "[", "(", or ".", suffices to distinguish between the possibilities of identifiers.
     * Any other token is not part of this term and should not be advanced over.
     */
    private fun compileTerm() {
        val termToken = tokenizer.getCurrentToken(advance = false)!!

        val unaryOperations = arrayOf(Token.Symbol.TILDE, Token.Symbol.DASH)
        val keywordConstant = arrayOf(Token.Keyword.TRUE, Token.Keyword.FALSE, Token.Keyword.NULL, Token.Keyword.THIS)

        when (termToken) {
            in unaryOperations -> {
                val unaryOperation = process(*unaryOperations)
                compileTerm()

                // We expect the term to be at the top of the stack.
                when (unaryOperation) {
                    Token.Symbol.DASH -> {
                        writer.writeArithmeticLogical(ArithmeticLogicalOperation.NEG)
                    }
                    Token.Symbol.TILDE -> {
                        writer.writeArithmeticLogical(ArithmeticLogicalOperation.NOT)
                    }
                    else -> throw IllegalStateException("Shouldn't happen.")
                }
            }
            Token.Symbol.OPENING_PARENTHESIS -> {
                process(Token.Symbol.OPENING_PARENTHESIS)
                compileExpression()
                process(Token.Symbol.CLOSING_PARENTHESIS)
            }
            is Token.IntegerConstant -> {
                val integerToken = process(Token.IntegerConstant(termToken.valueString.toInt()))
                writer.writePush(MemorySegment.CONSTANT, integerToken.value)
            }
            is Token.StringConstant -> {
                /*
                * Each string constant "ccc … c" is handled by:
                * 1. Pushing the string length onto the stack and calling the "String.new" constructor, and
                * 2. Pushing the character code of c on the stack and calling the String method "appendChar",
                * once for each character 'c' in the string (the Jack character set is documented in appendix 5).
                *
                * As documented in the String class API in appendix 6, both the "new" constructor and the "appendChar" method
                * return the string as the return value (i.e., they push the string object onto the stack).
                * This simplifies compilation, avoiding the need to re-push the string each time appendChar is called.
                */
                val stringToken = process(Token.StringConstant(termToken.valueString))
                writer.writePush(MemorySegment.CONSTANT, stringToken.valueString.length)
                writer.writeCall(subroutineName = "String.new", numArgs = 1)

                stringToken.valueString.forEach {
                    writer.writePush(MemorySegment.CONSTANT, HACK_CHARACTER_SET.getValue(it))
                    writer.writeCall(subroutineName = "String.appendChar", numArgs = 2)
                }
            }
            in keywordConstant -> {
                process(*keywordConstant)

                when (termToken) {
                    Token.Keyword.NULL, Token.Keyword.FALSE -> {
                        writer.writePush(MemorySegment.CONSTANT, 0)
                    }
                    Token.Keyword.TRUE -> {
                        // This sequence pushes the value −1 onto the stack. Which is all 1s in two-complement notation.
                        writer.writePush(MemorySegment.CONSTANT, 1)
                        writer.writeArithmeticLogical(ArithmeticLogicalOperation.NEG)
                    }
                    Token.Keyword.THIS -> {
                        // This
                        //command pushes the base address of the current object onto the stack.
                        writer.writePush(MemorySegment.THIS, 0)
                    }
                    else -> throw IllegalStateException("Shouldn't happen.")
                }
            }
            is Token.Identifier -> {
                // This will consume the identifier and allow us to disambiguate in subsequent lines what actions to take with the identifier.
                val identifierName = processIdentifier() // varName or subroutineName or className.

                // Look at the token now at the head.
                when (tokenizer.getCurrentToken(advance = false)) {
                    Token.Symbol.OPENING_BRACKET -> {
                        // Handles array access.
                        process(Token.Symbol.OPENING_BRACKET)
                        compileExpression()
                        process(Token.Symbol.CLOSING_BRACKET)

                        val identifierSymbol = lookupSymbol(identifierName.value)
                        // Add the array pointer address to the stack.
                        writer.writePush(identifierSymbol.kind.memorySegment, identifierSymbol.index)
                        // Now add it with the result of the compileExpression.
                        // This gives the memory address of the array element and places it at the top of the stack.
                        writer.writeArithmeticLogical(ArithmeticLogicalOperation.ADD)
                        // Orient the "THAT" with the element's address.
                        writer.writePop(MemorySegment.POINTER, 1)
                        // Finally, push the element's value to the top of the stack.
                        writer.writePush(MemorySegment.THAT, 0)
                    }
                    Token.Symbol.PERIOD, Token.Symbol.OPENING_PARENTHESIS -> {
                        // Handles both static and member method calls.

                        val fullSubroutineName = when (val token = tokenizer.getCurrentToken(advance = false)) {
                            Token.Symbol.PERIOD -> {
                                // We have a static method call. Or a member method call with a receiver.
                                process(Token.Symbol.PERIOD)
                                val receiverSymbol = lookupSymbolOptional(identifierName.value)
                                val subroutineName = processIdentifier().value

                                if (receiverSymbol != null) {
                                    // Subroutine is called on a receiver that we have in our symbol table.
                                    // We assume this is a method call and get the full method name based on the symbol type.
                                    "${receiverSymbol.type}.${subroutineName}"
                                } else {
                                    // If we don't have the receiver in our symbol table, we assume it is a static method call.
                                    "${identifierName.value}.${subroutineName}"
                                }
                            }
                            Token.Symbol.OPENING_PARENTHESIS -> {
                                // We have a method call on "this", we already consumed the subroutineName at the top, so return it here.
                                "${thisClassName}.${identifierName.value}"
                            }
                            else -> {
                                throw UnsupportedOperationException("Syntax error: '$token' not understood in subroutine call context.")
                            }
                        }

                        process(Token.Symbol.OPENING_PARENTHESIS)
                        val numExpressions = compileExpressionList()
                        process(Token.Symbol.CLOSING_PARENTHESIS)

                        writer.writeCall(fullSubroutineName, numExpressions)
                    }
                    else -> {
                        // Just a varName push its value to the stack.
                        val identifierSymbol = lookupSymbol(identifierName.value)
                        writer.writePush(identifierSymbol.kind.memorySegment, identifierSymbol.index)
                    }
                }
            } else -> {
                throw UnsupportedOperationException("Syntax error: '$termToken' term type is not supported.")
            }
        }
    }

    /**
     * Compiles a (possibly empty) comma-separated list of expressions.
     * Returns the number of expressions in the list.
     */
    private fun compileExpressionList(): Int {
        var numExpressions = 0

        if (tokenizer.getCurrentToken(advance = false) == Token.Symbol.CLOSING_PARENTHESIS) {
            // Call is immediately closed, so no expressions to see.
            return 0
        }

        compileExpression()
        numExpressions++

        // Handle additional expressions.
        while(tokenizer.getCurrentToken(advance = false) == Token.Symbol.COMMA) {
            process(Token.Symbol.COMMA)
            compileExpression()
            numExpressions++
        }

        return numExpressions
    }

    // Handles "type" from Jack's grammar.
    private fun processType(): Token {
        val typeToken = tokenizer.getCurrentToken(advance = false)!!
        return process(*getTypeTokens(typeToken))
    }

    /**
     * Returns a list of tokens that can be the type in a given context.
     * According to the Jack grammar, types are defined as "'int' | 'char' | 'boolean' | className".
     * If the token doesn't match any of the first three keywords, we assume it is an identifier (i.e a "className").
     */
    private fun getTypeTokens(token: Token): Array<Token> {
        return arrayOf(
            Token.Keyword.CHAR,
            Token.Keyword.INT,
            Token.Keyword.BOOLEAN,
            Token.Identifier(token.valueString)
        )
    }

    // Handles "identifier" from Jack's grammar.
    private fun processIdentifier(): Token.Identifier {
        val identifierToken = tokenizer.getCurrentToken(advance = false)!!
        return process(Token.Identifier(identifierToken.valueString))
    }

    private fun <T: Token> process(vararg expectedTokens: T): T {
        val currentToken = tokenizer.getCurrentToken(advance = false)!!
        val matchedToken = expectedTokens.find { it.valueString == currentToken.valueString }

        return if (matchedToken != null) {
            tokenizer.getCurrentToken(advance = true)!! as T
        } else {
            throw IllegalArgumentException("Syntax error: Expecting '${expectedTokens.toList()}' but got '${currentToken.valueString}' for '${writer.file.path}")
        }
    }

    fun close() {
        writer.close()
    }
}